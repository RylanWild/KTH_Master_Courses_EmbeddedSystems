# IL2212 Specification Model of the Application

This package contains the executable specification of the image processing application used for the IL2212 Embedded Software lab project, provided as a ForSyDe-Shallow (Haskell) model. 

## Installing

The easiest way to install and run this haskell model is to first install [Stack](https://docs.haskellstack.org/en/stable/README/) and then issue at the `model` folder:

    stack install
    
Once this command finishes, you should have acessible in your shell the executable `process-image` which is the executable spefication of the laboratory project. If you do, you can directly follow up with the "Running the testbench binary" section.
The easiest way to install haskell is, likely, to follow [the Haskell Platform](https://www.haskell.org/platform/) instructions for your OS.
	
## Generating the documentation
	
In order to generate de HTML documentation and open it, use `stack` again with the following command:

    stack haddock --open

in the `model` project's folder. The documentation is generated inside a hidden folder (in UNIX-like OS'es) `.stack-work`, which makes it a bit tedious to open on our own. You could copy and paste the links generated by `stack haddock` in the URL of your browser if you so wish, though.

## Running the testbench binary
	
To run the generated executable program, type in:

    process-image path/to/test-image-folder
	
For example:

    student@il2212:~/il2212-project/model$ process-image images/flag_tiny_mix/
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
    UUUUUUz--zUUUUUUUUUUUU
    UUUUUz+..+zUUUUUUUUUUU
                          
    UUUUUz+..+zUUUUUUUUUUU
    UUUUUUz--zUUUUUUUUUUUU
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
    UUUUUUz--zUUUUUUUUUUUU
    UUUUUz+..+zUUUUUUUUUUU
                          
    UUUUUz+..+zUUUUUUUUUUU
    UUUUUUz--zUUUUUUUUUUUU
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
    UUUUUUz--zUUUUUUUUUUUU
    UUUUUz+..+zUUUUUUUUUUU
                          
    UUUUUz+..+zUUUUUUUUUUU
    UUUUUUz--zUUUUUUUUUUUU
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
         -t=-t=           
         -t=-t=           
         -t=-t=           
         -t--t=           
    ttttttt--/tttttttttttt
    ttttt/=..=/ttttttttttt
                          
    ttttt/=..=/ttttttttttt
    tttttt/-:/tttttttttttt
         -t--t=           
         -t=-t=           
         -t=-t=           
         -t=-t=           
         -t=-t=           
         -t=-t=           
         -t=-t=           
         -t--t=           
    ttttttt--/tttttttttttt
    ttttt/=..=/ttttttttttt
                          
    ttttt/=..=/ttttttttttt
    tttttt/-:/tttttttttttt
         -t--t=           
         -t=-t=           
         -t=-t=           
         -t=-t=           
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=           
    UUUUUUz--zUUUUUUUUUUUU
    UUUUUz+..+zUUUUUUUUUUU
                          
    UUUUUz+..+zUUUUUUUUUUU
    UUUUUUz--zUUUUUUUUUUUU
         +U==U=           
         +U==U=           
         +U==U=           
         +U==U=  

You can make your own picture test suite, by collecting PPM images into a folder. Make sure that the `.ppm` files do not contain comment lines (i.e. starting with `#`), and that all images in one folder have the same dimensions.

## Testing functions in an interpreter

Finally, in order to test the individual functions of the library, you need to open an interpreter session and load the needed modules. The GHCi interpreter is called, inside the project, with:

    stack ghci

or,

    stack repl
	
You can always exit the session with `Ctrl`+`D`.
    
Your job will be to clearly understand the application specification, and a good practice to do that, apart from going through the code and through the documentation, is to test snippets and functions in the interpreter directly. As such, you would load in the interpreter either source files or, in this case, import library modules and test directly the functions or parts of the functions exported. 

For example, to test the `resize` functions exported by the `IL2212.ImageProcessing` module, you would roughly perform the following steps (consulting the generated documentation at the same time):

    Prelude Img U> ppm <- readFile "images/flag_tiny_good/flag_tiny_01.ppm"  -- the '<-' assignment is used for non-pure I/O functions
    Prelude Img U> let img = grayscale $ ppm2img ppm       -- the 'let' assignment is used for pure functions
    Prelude Img U> printImage $ mapMatrix truncate img     -- notation 'f $ g x' is equivalent to 'f (g x)'
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <78,78,78,78,78,78,78,78,78,78,126,196,194,194,172,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78>
    <198,198,198,198,198,198,198,198,198,198,197,193,194,194,195,199,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198>
    <194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194>
    <194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194,194>
    <198,198,198,198,198,198,198,198,198,198,197,193,194,194,195,199,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198>
    <78,78,78,78,78,78,78,78,78,78,126,196,194,194,172,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,80,80,80,80,80,130,196,194,194,173,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80>
    Prelude Img U> let smallImg = resize img
    Prelude Img U> printImage $ mapMatrix truncate smallImg 
    <80,80,80,80,80,163,194,126,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,163,194,126,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,163,194,126,80,80,80,80,80,80,80,80,80>
    <79,79,79,79,79,162,194,125,79,79,79,79,79,79,79,79,79>
    <196,196,196,196,196,194,194,195,196,196,196,196,196,196,196,196,196>
    <196,196,196,196,196,194,194,195,196,196,196,196,196,196,196,196,196>
    <79,79,79,79,79,162,194,125,79,79,79,79,79,79,79,79,79>
    <80,80,80,80,80,163,194,126,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,163,194,126,80,80,80,80,80,80,80,80,80>
    <80,80,80,80,80,163,194,126,80,80,80,80,80,80,80,80,80>
    
Another example: say you do not understand the construction of the function `resize`. In this case you would reconstruct it step-by-step, as seen in the source code:

    resize = mapMatrix (/ 4) . sumRows . sumCols
      where
        sumCols = mapV (mapV (reduceV (+)) . groupV 2)
        sumRows = mapV (reduceV (zipWithV (+))) . groupV 2

As an exercise, let us reconstruct what is happening in internal function `sumCols`, by using a dummy matrix as image:

	Prelude Img U V> import ForSyDe.Shallow.Core.Vector as V
    Prelude Img U V> let v = vector [1..9]
    Prelude Img U V> let dummy = vector [v,v,v,v]
    Prelude Img U V> dummy
    <<1,2,3,4,5,6,7,8,9>,<1,2,3,4,5,6,7,8,9>,<1,2,3,4,5,6,7,8,9>,<1,2,3,4,5,6,7,8,9>>
    Prelude Img U V> printImage dummy 
    <1,2,3,4,5,6,7,8,9>
    <1,2,3,4,5,6,7,8,9>
    <1,2,3,4,5,6,7,8,9>
    <1,2,3,4,5,6,7,8,9>
    Prelude Img U V> :t groupV 
    groupV :: Int -> Vector a -> Vector (Vector a)
    Prelude Img U V> let f1 = mapV (groupV 2)
    Prelude Img U V> :t f1
    f1 :: Vector (Vector a) -> Vector (Vector (Vector a))
    Prelude Img U V> printImage $ f1 dummy 
    <<1,2>,<3,4>,<5,6>,<7,8>>
    <<1,2>,<3,4>,<5,6>,<7,8>>
    <<1,2>,<3,4>,<5,6>,<7,8>>
    <<1,2>,<3,4>,<5,6>,<7,8>>
    Prelude Img U V> let f2 = mapV (reduceV (+))
    Prelude Img U V> :t f2
    f2 :: Num b => Vector (Vector b) -> Vector b
    Prelude Img U V>  f2 dummy 
    <45,45,45,45>
    Prelude Img U V> let f3 = mapV (mapV (reduceV (+)) . groupV 2)
    Prelude Img U V> :t f3
    f3 :: Num b => Vector (Vector b) -> Vector (Vector b)
    Prelude Img U V> printImage $ f3 dummy 
    <3,7,11,15>
    <3,7,11,15>
    <3,7,11,15>
    <3,7,11,15>
    
Hopefully the above exercises served as an appetizer to get your hands dirty with this ForSyDe-Haskell model. Understanding the system specification at such an abstraction level, albeit far from a specific implementation, enlarges the possible design space and opens up potential ways for alternative mappings and for exploiting various platforms. 

Good materials for helping with language or library related issues, which you should consult at any time:

* [the suggested book](http://learnyouahaskell.com/), or any beginners' manual;
* the generated API documentation;
* the [ForSyDe-Shallow](https://hackage.haskell.org/package/forsyde-shallow) API documentation;
* (especially) [Hoogle](https://www.haskell.org/hoogle/). 

Additional material on the core concepts will be given during the lectures. 
